---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../../../layouts/Layout.astro";
import PostCard from "../../../components/PostCard.astro";
import EmptyState from "../../../components/EmptyState.astro";
import { getLangFromUrl, useTranslations, usePlural } from "../../../i18n/utils";

export async function getStaticPaths() {
    const allPosts = await getCollection("blog");
    
    // Map tag data: lang -> Set<string> of tag IDs
    const tagsByLang: Record<string, Set<string>> = {
        en: new Set(),
        fr: new Set()
    };
    
    interface TagMap {
        [dateVal: number]: string[];
    }
    // pubDate.valueOf() -> tags array per post
    const postTagsByDate: Record<string, TagMap> = {
        en: {},
        fr: {}
    };

    allPosts.forEach((post: CollectionEntry<"blog">) => {
        const lang = post.slug.split('/')[0] as 'en' | 'fr';
        if (post.data.tags) {
            const rawTags = post.data.tags.map(t => t.toLowerCase().replace(/\s+/g, "-"));
            rawTags.forEach(tag => tagsByLang[lang].add(tag));
            postTagsByDate[lang][post.data.pubDate.valueOf()] = rawTags;
        }
    });

    const paths: any[] = [];
    
    // Generate paths strictly for existing tags per language
    Object.keys(tagsByLang).forEach((lang) => {
        tagsByLang[lang].forEach((tag) => {
            // Find which articles have this tag
            let relatedDates: number[] = [];
            for (const [dateVal, tgs] of Object.entries(postTagsByDate[lang])) {
                if (tgs.includes(tag)) relatedDates.push(Number(dateVal));
            }
            
            // Generate alternates by checking those exact same dates in other languages
            let alternates: { lang: string; href: string }[] = [];
            
            // Add self
            alternates.push({
                lang: lang,
                href: `${import.meta.env.BASE_URL.slice(1)}${lang}/tag/${tag}` // temporary relative path for template processing
            });

            // Find translation in other languages
            const otherLangs = ['en', 'fr'].filter(l => l !== lang);
            for (const otherLang of otherLangs) {
                // Find potential translated tags
                let possibleTags: Record<string, number> = {};
                for (const d of relatedDates) {
                    const transTags = postTagsByDate[otherLang]?.[d];
                    if (transTags) {
                        for (const t of transTags) {
                            possibleTags[t] = (possibleTags[t] || 0) + 1;
                        }
                    }
                }
                
                // If there's a highly correlated tag, link it!
                if (Object.keys(possibleTags).length > 0) {
                    // Get the tag that appeared in the most translated identical posts
                    const mostLikelyTag = Object.keys(possibleTags).reduce((a, b) => possibleTags[a] > possibleTags[b] ? a : b);
                    alternates.push({
                        lang: otherLang,
                        href: `${import.meta.env.BASE_URL.slice(1)}${otherLang}/tag/${mostLikelyTag}`
                    });
                }
            }

            paths.push({
                params: { lang, tag },
                props: { tagId: tag, rawAlternates: alternates },
            });
        });
    });

    return paths;
}

const { tagId, rawAlternates } = Astro.props;
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang as any);
const p = usePlural(lang as any);

// Resolve alternates correctly with Astro.site
const alternates = rawAlternates.map((alt: any) => ({
    lang: alt.lang,
    href: `${Astro.site}${alt.href}`
}));
const xDefault = alternates.find((a: any) => a.lang === 'en') || alternates[0];
if (xDefault) {
    alternates.push({ lang: 'x-default', href: xDefault.href });
}

const allPosts = await getCollection("blog", ({ slug }: { slug: string }) =>
    slug.startsWith(`${lang}/`)
);
const tagPosts = allPosts.filter(
    (post: CollectionEntry<"blog">) =>
        post.data.tags &&
        post.data.tags
            .map((tg: string) => tg.toLowerCase().replace(/\s+/g, "-"))
            .includes(tagId as string)
);

// We need the original tag name for display
const originalTag =
    tagPosts.length > 0
        ? tagPosts[0].data.tags?.find(
              (tg: string) => tg.toLowerCase().replace(/\s+/g, "-") === tagId
          )
        : tagId;
// Derive the dynamic OG image URL for this tag (sibling og.png endpoint)
const ogImageURL = new URL(
    `${import.meta.env.BASE_URL}${lang}/tag/${tagId}/og.png`,
    Astro.site
).toString();

// Build localized description â€” simple #{tag} param replacement
const tagDescription = t('tag.description' as any).replace('#{tag}', String(originalTag));
---

<Layout
    title={`#${originalTag}`}
    description={tagDescription}
    alternates={alternates}
    ogImage={ogImageURL}
    ogImageAlt={`#${originalTag}`}
>
    <div class="px-4 sm:px-8">
        <div class="w-full xl:mx-auto xl:max-w-[80rem] 2xl:max-w-[90rem]">
            <div class="flex flex-col gap-8 pt-2 sm:pt-10">
                <section class="pb-16">
                    <div class="space-y-8 max-w-4xl w-full mx-auto">
                        <header class="mb-8 space-y-4 text-center">
                            <div class="flex flex-col items-center gap-3">
                                <h1
                                    class="text-3xl sm:text-4xl font-bold tracking-tight text-balance text-foreground"
                                >
                                    <span
                                        class="text-muted-foreground font-normal"
                                        >#</span
                                    >{originalTag}
                                </h1>
                                <span
                                    class="inline-flex items-center rounded-full border border-border px-3 py-1 text-sm font-semibold uppercase tracking-wide text-muted-foreground"
                                    aria-label={`${p(tagPosts.length, "generic.posts")} with this tag`}
                                    >{p(tagPosts.length, "generic.posts")}</span
                                >
                            </div>
                        </header>

                        {
                            tagPosts.length === 0 ? (
                                <EmptyState message={t('generic.noPosts')} />
                            ) : (
                                <div class="grid grid-cols-1 gap-6">
                                    {tagPosts.map((post: CollectionEntry<"blog">) => (
                                        <PostCard post={post} lang={lang} variant="horizontal" />
                                    ))}
                                </div>
                            )
                        }
                    </div>
                </section>
            </div>
        </div>
    </div>
</Layout>
