---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../../../layouts/Layout.astro";
import PostCard from "../../../components/PostCard.astro";
import EmptyState from "../../../components/EmptyState.astro";
import { getLangFromUrl, useTranslations, usePlural } from "../../../i18n/utils";

export async function getStaticPaths() {
    const allPosts = await getCollection("blog");

    // For each lang+tag, store which post dates use it and at what index.
    // We match translated tags by position (index) within the tags array:
    // e.g. FR ["papotage", "bienvenue"][0] → EN ["talking", "welcome"][0]
    // This avoids the frequency-tie bug that arose when a post had multiple tags.

    interface PostTagEntry {
        dateVal: number;
        tagIndex: number;
    }

    // lang -> tag -> list of {dateVal, tagIndex} from posts using that tag
    const tagPostEntries: Record<string, Map<string, PostTagEntry[]>> = {
        en: new Map(),
        fr: new Map(),
    };

    // lang -> dateVal -> ordered tag array (slugified)
    const postTagsByDate: Record<string, Map<number, string[]>> = {
        en: new Map(),
        fr: new Map(),
    };

    allPosts.forEach((post: CollectionEntry<"blog">) => {
        const lang = post.slug.split("/")[0] as "en" | "fr";
        if (post.data.tags && post.data.tags.length > 0) {
            const rawTags = post.data.tags.map((tag: string) =>
                tag.toLowerCase().replace(/\s+/g, "-")
            );
            const dateVal = post.data.pubDate.valueOf();
            postTagsByDate[lang].set(dateVal, rawTags);

            rawTags.forEach((tag: string, tagIndex: number) => {
                if (!tagPostEntries[lang].has(tag)) {
                    tagPostEntries[lang].set(tag, []);
                }
                tagPostEntries[lang].get(tag)!.push({ dateVal, tagIndex });
            });
        }
    });

    const paths: any[] = [];

    Object.keys(tagPostEntries).forEach((lang) => {
        tagPostEntries[lang].forEach((entries, tag) => {
            const alternates: { lang: string; href: string }[] = [
                {
                    lang,
                    href: `${import.meta.env.BASE_URL.slice(1)}${lang}/tag/${tag}`,
                },
            ];

            const otherLangs = ["en", "fr"].filter((l) => l !== lang);
            for (const otherLang of otherLangs) {
                // For each post that uses this tag, look up the translated post (same pubDate)
                // and vote for the tag at the SAME index position. This guarantees
                // papotage (index 0) maps to talking (index 0), not welcome (index 1).
                const votes: Record<string, number> = {};
                for (const { dateVal, tagIndex } of entries) {
                    const otherTags = postTagsByDate[otherLang].get(dateVal);
                    if (otherTags && otherTags[tagIndex] !== undefined) {
                        const candidate = otherTags[tagIndex];
                        votes[candidate] = (votes[candidate] || 0) + 1;
                    }
                }
                if (Object.keys(votes).length > 0) {
                    const bestTag = Object.keys(votes).reduce((a, b) =>
                        votes[a] >= votes[b] ? a : b
                    );
                    alternates.push({
                        lang: otherLang,
                        href: `${import.meta.env.BASE_URL.slice(1)}${otherLang}/tag/${bestTag}`,
                    });
                }
            }

            paths.push({
                params: { lang, tag },
                props: { tagId: tag, rawAlternates: alternates },
            });
        });
    });

    return paths;
}

const { tagId, rawAlternates } = Astro.props;
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang as any);
const p = usePlural(lang as any);

// Resolve alternates correctly with Astro.site
const alternates = rawAlternates.map((alt: any) => ({
    lang: alt.lang,
    href: `${Astro.site}${alt.href}`
}));
const xDefault = alternates.find((a: any) => a.lang === 'en') || alternates[0];
if (xDefault) {
    alternates.push({ lang: 'x-default', href: xDefault.href });
}

const allPosts = await getCollection("blog", ({ slug }: { slug: string }) =>
    slug.startsWith(`${lang}/`)
);
const tagPosts = allPosts.filter(
    (post: CollectionEntry<"blog">) =>
        post.data.tags &&
        post.data.tags
            .map((tg: string) => tg.toLowerCase().replace(/\s+/g, "-"))
            .includes(tagId as string)
);

// We need the original tag name for display
const originalTag =
    tagPosts.length > 0
        ? tagPosts[0].data.tags?.find(
              (tg: string) => tg.toLowerCase().replace(/\s+/g, "-") === tagId
          )
        : tagId;
// Derive the dynamic OG image URL for this tag (sibling og.png endpoint)
const ogImageURL = new URL(
    `${import.meta.env.BASE_URL}${lang}/tag/${tagId}/og.png`,
    Astro.site
).toString();

// Build localized description — simple #{tag} param replacement
const tagDescription = t('tag.description' as any).replace('#{tag}', String(originalTag));
---

<Layout
    title={`#${originalTag}`}
    description={tagDescription}
    alternates={alternates}
    ogImage={ogImageURL}
    ogImageAlt={`#${originalTag}`}
>
    <div class="px-4 sm:px-8">
        <div class="w-full xl:mx-auto xl:max-w-[80rem] 2xl:max-w-[90rem]">
            <div class="flex flex-col gap-8 pt-2 sm:pt-10">
                <section class="pb-16">
                    <div class="space-y-8 max-w-4xl w-full mx-auto">
                        <header class="mb-8 space-y-4 text-center">
                            <div class="flex flex-col items-center gap-3">
                                <h1
                                    class="text-3xl sm:text-4xl font-bold tracking-tight text-balance text-foreground"
                                >
                                    <span
                                        class="text-muted-foreground font-normal"
                                        >#</span
                                    >{originalTag}
                                </h1>
                                <span
                                    class="inline-flex items-center rounded-full border border-border px-3 py-1 text-sm font-semibold uppercase tracking-wide text-muted-foreground"
                                    aria-label={`${p(tagPosts.length, "generic.posts")} with this tag`}
                                    >{p(tagPosts.length, "generic.posts")}</span
                                >
                            </div>
                        </header>

                        {
                            tagPosts.length === 0 ? (
                                <EmptyState message={t('generic.noPosts')} />
                            ) : (
                                <div class="grid grid-cols-1 gap-6">
                                    {tagPosts.map((post: CollectionEntry<"blog">) => (
                                        <PostCard post={post} lang={lang} variant="horizontal" />
                                    ))}
                                </div>
                            )
                        }
                    </div>
                </section>
            </div>
        </div>
    </div>
</Layout>
